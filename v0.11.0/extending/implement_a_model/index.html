<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implement a model · PlantBiophysics.jl</title><meta name="title" content="Implement a model · PlantBiophysics.jl"/><meta property="og:title" content="Implement a model · PlantBiophysics.jl"/><meta property="twitter:title" content="Implement a model · PlantBiophysics.jl"/><meta name="description" content="Documentation for PlantBiophysics.jl."/><meta property="og:description" content="Documentation for PlantBiophysics.jl."/><meta property="twitter:description" content="Documentation for PlantBiophysics.jl."/><meta property="og:url" content="https://VEZY.github.io/PlantBiophysics.jl/extending/implement_a_model/"/><meta property="twitter:url" content="https://VEZY.github.io/PlantBiophysics.jl/extending/implement_a_model/"/><link rel="canonical" href="https://VEZY.github.io/PlantBiophysics.jl/extending/implement_a_model/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="PlantBiophysics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PlantBiophysics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../getting_started/get_started/">TL;DR</a></li><li><a class="tocitem" href="../../getting_started/first_fit/">Parameter fitting</a></li></ul></li><li><a class="tocitem" href="../../concepts/package_design/">Design</a></li><li><a class="tocitem" href="../../variables/">Variables</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../../models/photosynthesis/">Photosynthesis</a></li><li><a class="tocitem" href="../../models/gs/">Stomatal conductance</a></li><li><a class="tocitem" href="../../models/energy_balance/">Energy balance</a></li><li><a class="tocitem" href="../../models/light/">Light interception</a></li></ul></li><li><a class="tocitem" href="../../climate/microclimate/">Micro-climate</a></li><li><a class="tocitem" href="../../fitting/parameter_fitting/">Tutorial: Parameter fitting</a></li><li><span class="tocitem">Tutorial: Simulation</span><ul><li><a class="tocitem" href="../../simulation/first_simulation/">Simple Simulation</a></li><li><a class="tocitem" href="../../simulation/several_simulation/">Several time steps</a></li><li><a class="tocitem" href="../../simulation/several_objects_simulation/">Several objects</a></li><li><a class="tocitem" href="../../simulation/mtg_simulation/">Whole-plant simulation</a></li></ul></li><li><a class="tocitem" href="../../simulation/uncertainty_propagation/">Tutorial: Uncertainty propagation</a></li><li><span class="tocitem">Extending PlantBiophysics</span><ul><li class="is-active"><a class="tocitem" href>Implement a model</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Inspiration"><span>Inspiration</span></a></li><li><a class="tocitem" href="#Requirements"><span>Requirements</span></a></li><li><a class="tocitem" href="#Example:-the-Ball-and-Berry-model"><span>Example: the Ball and Berry model</span></a></li><li><a class="tocitem" href="#More-details-on-model-implementations"><span>More details on model implementations</span></a></li></ul></li><li><a class="tocitem" href="../implement_a_process/">Implement a process</a></li></ul></li><li><a class="tocitem" href="../../functions/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Extending PlantBiophysics</a></li><li class="is-active"><a href>Implement a model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implement a model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/docs/src/extending/implement_a_model.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="model_implementation_page"><a class="docs-heading-anchor" href="#model_implementation_page">Model implementation in 5 minutes</a><a id="model_implementation_page-1"></a><a class="docs-heading-anchor-permalink" href="#model_implementation_page" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p><code>PlantBiophysics.jl</code> was designed to make new model implementation very simple thanks to <code>PlantSimEngine</code>. So let&#39;s learn about how to implement your own model with a simple example: implementing a new stomatal conductance model.</p><h2 id="Inspiration"><a class="docs-heading-anchor" href="#Inspiration">Inspiration</a><a id="Inspiration-1"></a><a class="docs-heading-anchor-permalink" href="#Inspiration" title="Permalink"></a></h2><p>If you want to implement a new model, the best way to do it is to start from another implementation.</p><p>So for a photosynthesis model, I advise you to look at the implementation of the <code>FvCB</code> model in this Julia file: <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/photosynthesis/FvCB.jl">src/photosynthesis/FvCB.jl</a>.</p><p>For an energy balance model you can look at the implementation of the <code>Monteith</code> model in <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/energy/Monteith.jl">src/energy/Monteith.jl</a>, and for a stomatal conductance model in <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/conductances/stomatal/medlyn.jl">src/conductances/stomatal/medlyn.jl</a>.</p><h2 id="Requirements"><a class="docs-heading-anchor" href="#Requirements">Requirements</a><a id="Requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Requirements" title="Permalink"></a></h2><p>In those files, you&#39;ll see that in order to implement a new model you&#39;ll need to implement:</p><ul><li>a structure, used to hold the parameter values and to dispatch to the right method</li><li>the actual model, developed as a method for the <code>run!</code> function</li><li>some helper functions used by the package and/or the users</li></ul><p>Let&#39;s take a simple example with a new model for the stomatal conductance: the Ball and Berry model.</p><h2 id="Example:-the-Ball-and-Berry-model"><a class="docs-heading-anchor" href="#Example:-the-Ball-and-Berry-model">Example: the Ball and Berry model</a><a id="Example:-the-Ball-and-Berry-model-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-the-Ball-and-Berry-model" title="Permalink"></a></h2><h3 id="The-structure"><a class="docs-heading-anchor" href="#The-structure">The structure</a><a id="The-structure-1"></a><a class="docs-heading-anchor-permalink" href="#The-structure" title="Permalink"></a></h3><p>The first thing to do is to implement a structure for your model.</p><p>The purpose of the structure is two-fold:</p><ul><li>hold the parameter values</li><li>dispatch to the right method when calling the process function</li></ul><p>Let&#39;s take the <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/conductances/stomatal/medlyn.jl#L37">stomatal conductance model from Medlyn et al. (2011)</a> as a starting point. The structure of the model (or type) is defined as follows:</p><pre><code class="language-julia hljs">struct Medlyn{T} &lt;: AbstractStomatal_ConductanceModel
    g0::T
    g1::T
    gs_min::T
end</code></pre><p>The first line defines the name of the model (<code>Medlyn</code>), with the types that will be used for the parameters. Then it defines the structure as a subtype of <a href="../../functions/#PlantBiophysics.AbstractStomatal_ConductanceModel"><code>AbstractStomatal_ConductanceModel</code></a>. This step is very important as it tells to the package what kind of process the model simulates. In this case, it is a stomatal conductance model, that&#39;s why we use <a href="../../functions/#PlantBiophysics.AbstractStomatal_ConductanceModel"><code>AbstractStomatal_ConductanceModel</code></a>. We would use <a href="../../functions/#PlantBiophysics.AbstractPhotosynthesisModel"><code>AbstractPhotosynthesisModel</code></a> instead for a photosynthesis model, <a href="../../functions/#PlantBiophysics.AbstractEnergy_BalanceModel"><code>AbstractEnergy_BalanceModel</code></a> for an energy balance model, and <a href="../../functions/#PlantBiophysics.AbstractLight_InterceptionModel"><code>AbstractLight_InterceptionModel</code></a> for a light interception model.</p><p>These abstract structures are automatically defined when defining a process using the <code>@process</code> macro from <code>PlantSimEngine.jl</code> (which PlantBiophysics is built upon). </p><p>For another example, the <a href="../../models/photosynthesis/#Fvcb"><code>Fvcb</code></a> model is a subtype of <a href="../../functions/#PlantBiophysics.AbstractPhotosynthesisModel"><code>AbstractPhotosynthesisModel</code></a>. You can check this using:</p><pre><code class="language-julia hljs">Fvcb &lt;: AbstractPhotosynthesisModel</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Then comes the parameters names, and their types. The type of the parameters is always forced to be of the same type in our example. This is done using the <code>T</code> notation as follows:</p><ul><li>we say that our structure <code>Medlyn</code> is a parameterized <code>struct</code> by putting <code>T</code> in between brackets after the name of the <code>struct</code></li><li>We put <code>::T</code> after our parameter names in the <code>struct</code>. This way Julia knows that all parameters must be of same type <code>T</code>.</li></ul><p>The <code>T</code> is completely free, you can use any other letter or word instead. If you have parameters that you know will be of different types, you can either force their type, or make them parameterizable too, using another letter, <em>e.g.</em>:</p><pre><code class="language-julia hljs">struct YourStruct{T,S} &lt;: AbstractStomatal_ConductanceModel
    g0::T
    g1::T
    gs_min::T
    integer_param::S
end</code></pre><p>Parameterized types are very useful because they let the user choose the type of the parameters, and potentially dispatch on them.</p><p>But why not forcing the type such as the following:</p><pre><code class="language-julia hljs">struct YourStruct &lt;: AbstractStomatal_ConductanceModel
    g0::Float64
    g1::Float64
    gs_min::Float64
    integer_param::Int
end</code></pre><p>Well, you can do that. But you&#39;ll lose a lot of the magic Julia has to offer this way.</p><p>For example a user could use the <code>Particles</code> type from <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a> to make automatic uncertainty propagation, and this is only possible if the type is parameterizable.</p><p>So let&#39;s implement a new structure for our stomatal conductance model:</p><pre><code class="language-julia hljs">struct BandB{T} &lt;: AbstractStomatal_ConductanceModel
    g0::T
    g1::T
    gs_min::T
end</code></pre><p>Well, the only thing we had to change relative to the one from Medlyn is the name, easy! This is because both models share the same parameters.</p><h3 id="The-method"><a class="docs-heading-anchor" href="#The-method">The method</a><a id="The-method-1"></a><a class="docs-heading-anchor-permalink" href="#The-method" title="Permalink"></a></h3><p>The models are implemented as a new method for the <code>run!</code> function. The tailing exclamation point is used in Julia to tell users the function is mutating its input, <em>i.e.</em> it modifies it.</p><p>Your implementation should always modify the input status and return nothing. This ensures that models compute fast.</p><p>We extend <code>run!</code> because then <code>PlantSimEngine</code> handles every other details, such as checking that the object is correctly initialized, building the dependency graph between models, applying the computations over objects and time-steps in parallel, etc... This is nice because as a developer you don&#39;t have to deal with those details, and you can just concentrate on your implementation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If your model calls another one (hard-coupled), you&#39;ll have to use the internal call directly to avoid the overheads of the generic functions to avoid all checks for performance.</p></div></div><p>Here we are trying to implement a new stomatal conductance model. Well, this one is the most complicated process to implement actually, because it is computed on two steps: <code>run!</code> and <code>gs_closure</code>.</p><p><code>gs_closure</code> is the function that actually implements the conductance model, but only the stomatal closure part. This one does not modify its input, it computes the result and returns it. Then <code>run!</code> uses this output to compute the stomatal conductance. But why not implementing just <code>run!</code>? Because <code>gs_closure</code> is used elsewhere, usually in the photosynthesis model, before actually computing the stomatal conductance.</p><p>In practice, the <code>run!</code> implementation is rather generic and will not be modified by developers. They will rather implement their method for <code>gs_closure</code>, that will be used automatically by <code>run!</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>We need to import all the functions we need to use or extend, so Julia knows we are extending the methods from PlantSimEngine, and not defining our own functions. To do so, you can prefix the functions by the package name, or import them once <em>e.g.</em>:</p><pre><code class="nohighlight hljs">    import PlantSimEngine: inputs_, outputs_
    import PlantBiohysics: run!, run!</code></pre></div></div><p>So let&#39;s do it! Here is our own implementation of the stomatal closure for a <code>ModelList</code> component models:</p><pre><code class="language-julia hljs">function PlantBiophysics.gs_closure(::BandB, models, status, meteo, constants, extra)
    models.stomatal_conductance.g1 * meteo.Rh / status.Cₛ
end</code></pre><p>The first argument (<code>::BandB</code>) means this method will only execute when the function is called with a first argument that is of type <code>BandB</code>. This is our way of telling Julia that this method is implementing the <code>BandB</code> algorithm.</p><p>An important thing to note is that our variables are stored in different structures:</p><ul><li><code>models</code>: the models parameters</li><li><code>status</code>: the input and output variables of the models</li><li><code>meteo</code>: the micro-climatic conditions</li><li><code>constants</code>: the constants</li><li><code>extras</code>: any other value or object, this is used for example to pass the node of a MultiScaleTreeGraph</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The micro-meteorological conditions are always given for one time-step inside the models methods. The conditions with several time-steps are handled earlier by the generic functions.</p></div></div><p>OK ! So that&#39;s it ? Almost. One last thing to do is to define a method for inputs/outputs so that PlantSimEngine knows which variables are needed for our model, and which it computes. Remember that the actual model is implemented for <code>run!</code>, so we have to tell PlantSimEngine which ones are needed, and what are their default value:</p><ul><li>Inputs: <code>:Rh</code> and <code>:Cₛ</code> for our specific implementation, and <code>:A</code> for <code>run!</code></li><li>Outputs: our model does not compute any new variable, and <code>run!</code> computes, well, <code>:Gₛ</code></li></ul><p>Here is how we actually implement our methods:</p><pre><code class="language-julia hljs">import PlantSimEngine
function PlantSimEngine.inputs_(::BandB)
    (Rh=-Inf,Cₛ=-Inf,A=-Inf)
end

function PlantSimEngine.outputs_(::BandB)
    (Gₛ=-Inf,)
end</code></pre><p>Note that both function end with an &quot;<em>&quot;. This is because these functions are internal, they will not be called by the users directly. Users will use <code>inputs</code> and <code>outputs</code> instead, which call `inputs</em><code>and</code>outputs_`, but stripping out the default values.</p><h3 id="The-utility-functions"><a class="docs-heading-anchor" href="#The-utility-functions">The utility functions</a><a id="The-utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#The-utility-functions" title="Permalink"></a></h3><p>Before running a simulation, you can do a little bit more for your implementation (optional).</p><p>First, you can add a method for type promotion:</p><pre><code class="language-julia hljs">function BandB(g0,g1,gs_min)
    BandB(promote(g0,g1,gs_min))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.BandB</code></pre><p>This allows your user to instantiate your model parameters using different types of inputs. For example they may use this:</p><pre><code class="language-julia hljs">BandB(0,2.0,0.001)</code></pre><p>You don&#39;t see a problem? Well your users won&#39;t either.</p><p>Here&#39;s the problem: we use parametric types, and when we declared our structure, we said that all fields in our type will share the same type. This is the <code>T</code> here:</p><pre><code class="language-julia hljs">struct BandB{T} &lt;: AbstractStomatal_ConductanceModel
    g0::T
    g1::T
    gs_min::T
end</code></pre><p>And in our example above, the user provides <code>0</code> as the first argument. Well, this is an integer, not a floating point number like the two others. That&#39;s were the promotion is really helpful. It will convert all your inputs to the same type. In our example it will convert <code>0</code> to <code>0.0</code>.</p><p>A second thing also is to help your user with default values for some parameters (if applicable). For example a user will almost never change the value of the minimum stomatal conductance. So we can provide a default value like so:</p><pre><code class="language-julia hljs">BandB(g0,g1) = BandB(g0, g1, oftype(0.001, g0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.BandB</code></pre><p>Now the user can call <code>BandB</code> with only two values, and the third one will be set to <code>0.001</code>.</p><p>Another useful thing to provide to the user is the ability to instantiate your model type with keyword values. You can do it by adding the following method:</p><pre><code class="language-julia hljs">BandB(;g0,g1) = BandB(g0,g1,oftype(g0,0.001))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.BandB</code></pre><p>Did you notice the <code>;</code> before the argument? It tells Julia that we want those arguments provided as keywords, so now we can call <code>BandB</code> like this:</p><pre><code class="language-julia hljs">BandB(g0 = 0.0, g1 = 2.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.BandB{Float64}(0.0, 2.0, 0.001)</code></pre><p>This is nice, but again, completely optional.</p><p>One more thing to implement is a method for the <code>dep</code> function that tells PlantSimEngine which processes (and models) are needed for your model to run (<em>i.e.</em> if your model is coupled to another model).</p><p>Our example model does not call another model, so we don&#39;t need to implement it. But we can look at <em>e.g.</em> the implementation for <a href="../../models/photosynthesis/#Fvcb"><code>Fvcb</code></a> to see how it works:</p><pre><code class="language-julia hljs">PlantSimEngine.dep(::Fvcb) = (stomatal_conductance=AbstractStomatal_ConductanceModel,)</code></pre><p>Here we say to PlantSimEngine that the <code>Fvcb</code> model needs a model of type <code>AbstractStomatal_ConductanceModel</code> in the stomatal conductance process.</p><p>The next optional thing to implement is a method for the <code>eltype</code> function:</p><pre><code class="language-julia hljs">Base.eltype(x::BandB{T}) where {T} = T</code></pre><p>This one helps Julia to know the type of the elements in your structure, and make it faster.</p><p>And finally the last optional thing to add is a trait that defines how the model can be run in parallel over space (<em>i.e.</em> over objects) or time (<em>i.e.</em> over time-steps).</p><p>By default all models are considered <strong>not</strong> to be executable in parallel. But if you implement a model that is parallel over objects, you can define the trait like so:</p><pre><code class="language-julia hljs">PlantSimEngine.ObjectDependencyTrait(::Type{&lt;:BandB}) = PlantSimEngine.IsObjectIndependent()</code></pre><p>And if it is executable in parallel over time-steps, you can define it like this:</p><pre><code class="language-julia hljs">PlantSimEngine.TimeStepDependencyTrait(::Type{&lt;:BandB}) = PlantSimEngine.IsTimeStepIndependent()</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>A model that is defined executable in parallel will not necessarily will. First, the user has to pass a parallel <code>executor</code> to <a href="../../functions/#PlantSimEngine.run!"><code>run!</code></a> (<em>e.g.</em> <code>ThreadedEx</code>). Second, if the model is coupled with another model that is not executable in parallel, <code>PlantSimEngine</code> will run all models in sequential.</p></div></div><p>OK that&#39;s it! Now you have a full new implementation of the stomatal conductance model! I hope it was clear and that you understood everything. If you think some sections could be improved, you can make a PR on this doc, or open an issue so I can improve it.</p><h2 id="More-details-on-model-implementations"><a class="docs-heading-anchor" href="#More-details-on-model-implementations">More details on model implementations</a><a id="More-details-on-model-implementations-1"></a><a class="docs-heading-anchor-permalink" href="#More-details-on-model-implementations" title="Permalink"></a></h2><p>Here is another example with a different approach in case you need it. So let&#39;s change our example from the stomatal conductance to the photosynthesis. For example <a href="../../models/photosynthesis/#Fvcb"><code>Fvcb</code></a> implements the model or Farquhar et al. (1980) to simulate the photosynthesis of C3 plants.</p><p>When the user calls <code>run!</code>, PlantBiophysics looks into the component models type, and the type of the model implemented for the photosynthesis, in this case, <a href="../../models/photosynthesis/#Fvcb"><code>Fvcb</code></a>.</p><p>Then, it calls another, internal method of <a href="../../functions/#PlantSimEngine.run!"><code>run!</code></a> that will dispatch the computation to the method that implements the model. This method looks like this:</p><pre><code class="language-julia hljs">function PlantSimEngine.run!(::Fvcb, models, status, meteo, constants=Constants(), extras=nothing)

    [...]

end</code></pre><p>Where <code>[...]</code> represent the lines of code implementing the model (not shown here).</p><p>The interesting bit is in the function declaration at the top. This is where all the magic happens. The first argument let Julia know that this is the method for computing the <code>Fvcb</code> model.</p><p>Now if we look again at what are the fields of a <code>ModelList</code>:</p><pre><code class="language-julia hljs">fieldnames(ModelList)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:models, :status, :vars_not_propagated)</code></pre><p>we see that it has two fields: <code>models</code> and <code>status</code>. The first one is a list of models named after the process they simulate. So if we want to simulate the photosynthesis with the <code>Fvcb</code> model, our <code>ModelList</code> needs an instance of the <a href="../../models/photosynthesis/#Fvcb"><code>Fvcb</code></a> structure for the <code>photosynthesis</code> process, like so:</p><pre><code class="language-julia hljs">leaf = ModelList(Fvcb());
leaf.models.photosynthesis</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Fvcb{Float64}(25.0, 200.0, 250.0, 0.6, 9999.0, 46390.0, 210.0, 29680.0, 200000.0, 631.88, 58550.0, 200000.0, 629.26, 0.24, 0.7)</code></pre><p>The <code>photosynthesis</code> field is then used as the first argument to the call to the internal method of <code>run!</code>, which will call the method that implements <a href="../../models/photosynthesis/#Fvcb"><code>Fvcb</code></a>, because our <code>photosynthesis</code> field is of type <a href="../../models/photosynthesis/#Fvcb"><code>Fvcb</code></a>.</p><p>So if we want to implement our own model for the photosynthesis, we could do:</p><pre><code class="language-julia hljs"># Make the struct to hold the parameters:
struct OurModel{T} &lt;: AbstractPhotosynthesisModel
    a::T
    b::T
    c::T
end

# Instantiate the struct with default values + kwargs:
function OurModel(;a = 400.0, b = 1000.0, c = 1.5)
    OurModel(promote(a,b)...)
end

# Define inputs:
function PlantSimEngine.inputs_(::OurModel)
    (aPPFD=-Inf, Tₗ=-Inf, Cₛ=-Inf)
end

# Define outputs:
function PlantSimEngine.outputs_(::OurModel)
    (A=-Inf, Gₛ=-Inf)
end

# Tells Julia what is the type of elements:
Base.eltype(x::OurModel{T}) where {T} = T

# Tells PlantSimEngine that the model is executable in parallel over objects:
PlantSimEngine.ObjectDependencyTrait(::Type{&lt;:OurModel}) = PlantSimEngine.IsObjectIndependent()

# and time-steps:
PlantSimEngine.TimeStepDependencyTrait(::Type{&lt;:OurModel}) = PlantSimEngine.IsTimeStepIndependent()

# Implement the photosynthesis model:
function PlantSimEngine.run!(::OurModel, models, status, meteo, constants=Constants(), extras=nothing)

    status.A =
        status.Cₛ / models.photosynthesis.a +
        status.aPPFD / models.photosynthesis.b +
        status.Tₗ / models.photosynthesis.c

    PlantSimEngine.run!(models.stomatal_conductance, models, status, meteo, constants, extras)
end</code></pre><p>🥳 And that&#39;s it! 🥳</p><p>We have a new model for photosynthesis that is coupled with the stomatal conductance.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is a dummy photosynthesis model. Don&#39;t use it, it is very wrong biologically speaking!</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Notice that we compute the stomatal conductance directly using the internal method of <code>run!</code> that takes the type of model as first argument. We do this for speed, because the generic function <code>run!</code> does some checks on its inputs every time it is called, while the internal method only does the computation. We don&#39;t need the extra checks and dependency graph computations because they are already done at the first call.</p></div></div><p>Now if we want to make a simulation, we can simply do:</p><pre><code class="language-julia hljs">using PlantMeteo
meteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)

leaf =
    ModelList(
        OurModel(1.0, 2.0, 3.0),
        Medlyn(0.03, 12.0),
        status = (Tₗ = 25.0, aPPFD = 1000.0, Cₛ = 400.0, Dₗ = meteo.VPD)
    )
# NB: we need  to initalise Tₗ, aPPFD and Cₛ

run!(leaf,meteo,Constants())
leaf[:A]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 908.3333333333334</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../simulation/uncertainty_propagation/">« Tutorial: Uncertainty propagation</a><a class="docs-footer-nextpage" href="../implement_a_process/">Implement a process »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 25 June 2024 19:11">Tuesday 25 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
